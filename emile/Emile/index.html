<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Emile (emile.Emile)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">emile</a> &#x00BB; Emile</nav><h1>Module <code>Emile</code></h1><p>Emile module, parser of e-mail address.</p><nav class="toc"><ul><li><a href="#pretty-printers.">Pretty-printers.</a></li><li><a href="#equal-&amp;-compare.">Equal &amp; Compare.</a></li><li><a href="#parsers">Parsers</a></li></ul></nav></header><dl><dt class="spec type" id="type-raw"><a href="#type-raw" class="anchor"></a><code><span class="keyword">type</span> raw</code><code> = </code><table class="variant"><tr id="type-raw.Quoted_printable" class="anchored"><td class="def constructor"><a href="#type-raw.Quoted_printable" class="anchor"></a><code>| </code><code><span class="constructor">Quoted_printable</span> <span class="keyword">of</span> (string, [ `Msg of string ]) Stdlib.result</code></td></tr><tr id="type-raw.Base64" class="anchored"><td class="def constructor"><a href="#type-raw.Base64" class="anchor"></a><code>| </code><code><span class="constructor">Base64</span> <span class="keyword">of</span> (string, [ `Msg of string ]) Stdlib.result</code></td></tr></table></dt><dd><p>An e-mail address can contain as a part of a <a href="index.html#type-phrase"><code>phrase</code></a> (identifier) an encoded string. Standards describe 2 kinds of encoding:</p><ul><li>Quoted Printable: used to insert hexadecimal value with the <code>=</code> operator.</li><li>Base 64: string encoded in MIME's Base64</li></ul><p>Parser already decodes encoded <a href="index.html#type-raw"><code>raw</code></a>, the client can use it as is.</p></dd></dl><dl><dt class="spec type" id="type-word"><a href="#type-word" class="anchor"></a><code><span class="keyword">type</span> word</code> = <code>[ </code><table class="variant"><tr id="type-word.Atom" class="anchored"><td class="def constructor"><a href="#type-word.Atom" class="anchor"></a><code>| </code><code>`Atom <span class="keyword">of</span> string</code></td></tr><tr id="type-word.String" class="anchored"><td class="def constructor"><a href="#type-word.String" class="anchor"></a><code>| </code><code>`String <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>The local part of an e-mail address is composed by two kinds of <i>word</i>s:</p><ul><li><code>`Atom</code> is string as is.</li><li><code>`String</code> is a string surrounded by double-quote to allow white-space.</li></ul><p>The second kind is sanitized — we deleted double-quote which surround <code>string</code>.</p></dd></dl><dl><dt class="spec type" id="type-local"><a href="#type-local" class="anchor"></a><code><span class="keyword">type</span> local</code><code> = <a href="index.html#type-word">word</a> list</code></dt><dd><p>Local part of e-mail address.</p></dd></dl><dl><dt class="spec type" id="type-addr"><a href="#type-addr" class="anchor"></a><code><span class="keyword">type</span> addr</code><code> = </code><table class="variant"><tr id="type-addr.IPv4" class="anchored"><td class="def constructor"><a href="#type-addr.IPv4" class="anchor"></a><code>| </code><code><span class="constructor">IPv4</span> <span class="keyword">of</span> Ipaddr.V4.t</code></td></tr><tr id="type-addr.IPv6" class="anchored"><td class="def constructor"><a href="#type-addr.IPv6" class="anchor"></a><code>| </code><code><span class="constructor">IPv6</span> <span class="keyword">of</span> Ipaddr.V6.t</code></td></tr><tr id="type-addr.Ext" class="anchored"><td class="def constructor"><a href="#type-addr.Ext" class="anchor"></a><code>| </code><code><span class="constructor">Ext</span> <span class="keyword">of</span> string * string</code></td></tr></table></dt><dd><p>Subset of domain described by RFC5321 which contains 3 kinds of address:</p><ul><li><code>IPv4</code>: a valid IPv4 address</li><li><code>IPv6</code>: a valid IPv6 address</li><li><code>Ext (ldh, value)</code>: an extended kind of domain recognized by <code>ldh</code> identifier which valus is <code>value</code></li></ul><p>Parser of <code>IPv4</code> and <code>IPv6</code> was done by <code>Ipaddr</code>. An extended kind <code>Ext</code> needs to be resolved by the client.</p></dd></dl><dl><dt class="spec type" id="type-domain"><a href="#type-domain" class="anchor"></a><code><span class="keyword">type</span> domain</code> = <code>[ </code><table class="variant"><tr id="type-domain.Domain" class="anchored"><td class="def constructor"><a href="#type-domain.Domain" class="anchor"></a><code>| </code><code>`Domain <span class="keyword">of</span> string list</code></td></tr><tr id="type-domain.Addr" class="anchored"><td class="def constructor"><a href="#type-domain.Addr" class="anchor"></a><code>| </code><code>`Addr <span class="keyword">of</span> <a href="index.html#type-addr">addr</a></code></td></tr><tr id="type-domain.Literal" class="anchored"><td class="def constructor"><a href="#type-domain.Literal" class="anchor"></a><code>| </code><code>`Literal <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>Domain part of e-mail address. A domain integrate kinds from RFC5321 (see <a href="index.html#type-addr"><code>addr</code></a>), a domain described by RFC5322 and a <code>`Literal</code> which is the last <i>best-effort</i> value possible as a domain.</p><p><code>Emile</code> <b>does not</b> resolve domain.</p></dd></dl><dl><dt class="spec type" id="type-phrase"><a href="#type-phrase" class="anchor"></a><code><span class="keyword">type</span> phrase</code><code> = [ `Dot | `Word of <a href="index.html#type-word">word</a> | `Encoded of string * <a href="index.html#type-raw">raw</a> ] list</code></dt><dd><p>A phrase is a sentence to associate a name with an e-mail address or a group of e-mail addresses. <code>`Encoded</code> value <b>is not</b> normalized on the <i>charset</i> specified. The encoded's string is decoded as is only. For example, <code>`Encoded</code> can inform to use KOI-8 encoding (cyrillic charset). However, <code>Emile</code> does not check if value is a valid KOI-8 string, nor normalizes to unicode. <code>Emile</code> just decodes it as is.</p></dd></dl><dl><dt class="spec type" id="type-mailbox"><a href="#type-mailbox" class="anchor"></a><code><span class="keyword">type</span> mailbox</code><code> = </code><code>{</code><table class="record"><tr id="type-mailbox.name" class="anchored"><td class="def field"><a href="#type-mailbox.name" class="anchor"></a><code>name : <a href="index.html#type-phrase">phrase</a> option;</code></td></tr><tr id="type-mailbox.local" class="anchored"><td class="def field"><a href="#type-mailbox.local" class="anchor"></a><code>local : <a href="index.html#type-local">local</a>;</code></td></tr><tr id="type-mailbox.domain" class="anchored"><td class="def field"><a href="#type-mailbox.domain" class="anchor"></a><code>domain : <a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list;</code></td></tr></table><code>}</code></dt><dd><p>A mailbox is an e-mail address. It contains an optional name (see <a href="index.html#type-phrase"><code>phrase</code></a>), a local-part (see <a href="index.html#type-local"><code>local</code></a>) and one or more <a href="index.html#type-domain"><code>domain</code></a>(s).</p></dd></dl><dl><dt class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> group</code><code> = </code><code>{</code><table class="record"><tr id="type-group.group" class="anchored"><td class="def field"><a href="#type-group.group" class="anchor"></a><code>group : <a href="index.html#type-phrase">phrase</a>;</code></td></tr><tr id="type-group.mailboxes" class="anchored"><td class="def field"><a href="#type-group.mailboxes" class="anchor"></a><code>mailboxes : <a href="index.html#type-mailbox">mailbox</a> list;</code></td></tr></table><code>}</code></dt><dd><p>A group is a named set of <a href="index.html#type-mailbox"><code>mailbox</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-address"><a href="#type-address" class="anchor"></a><code><span class="keyword">type</span> address</code><code> = <a href="index.html#type-local">local</a> * (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list)</code></dt><dd><p>A basic e-mail address.</p></dd></dl><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> set</code> = <code>[ </code><table class="variant"><tr id="type-set.Mailbox" class="anchored"><td class="def constructor"><a href="#type-set.Mailbox" class="anchor"></a><code>| </code><code>`Mailbox <span class="keyword">of</span> <a href="index.html#type-mailbox">mailbox</a></code></td></tr><tr id="type-set.Group" class="anchored"><td class="def constructor"><a href="#type-set.Group" class="anchor"></a><code>| </code><code>`Group <span class="keyword">of</span> <a href="index.html#type-group">group</a></code></td></tr></table><code> ]</code></dt><dd><p>The <i>Emile</i>'s set type which is a <i>singleton</i> (only one <a href="index.html#type-mailbox"><code>mailbox</code></a>) or a <i>set</i> of e-mail addresses (a <a href="index.html#type-group"><code>group</code></a>).</p></dd></dl><section><header><h3 id="pretty-printers."><a href="#pretty-printers." class="anchor"></a>Pretty-printers.</h3></header><dl><dt class="spec value" id="val-pp_addr"><a href="#val-pp_addr" class="anchor"></a><code><span class="keyword">val</span> pp_addr : <a href="index.html#type-addr">addr</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_domain"><a href="#val-pp_domain" class="anchor"></a><code><span class="keyword">val</span> pp_domain : <a href="index.html#type-domain">domain</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_word"><a href="#val-pp_word" class="anchor"></a><code><span class="keyword">val</span> pp_word : <a href="index.html#type-word">word</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_local"><a href="#val-pp_local" class="anchor"></a><code><span class="keyword">val</span> pp_local : <a href="index.html#type-local">local</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_raw"><a href="#val-pp_raw" class="anchor"></a><code><span class="keyword">val</span> pp_raw : <a href="index.html#type-raw">raw</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_phrase"><a href="#val-pp_phrase" class="anchor"></a><code><span class="keyword">val</span> pp_phrase : <a href="index.html#type-phrase">phrase</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_mailbox"><a href="#val-pp_mailbox" class="anchor"></a><code><span class="keyword">val</span> pp_mailbox : <a href="index.html#type-mailbox">mailbox</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_group"><a href="#val-pp_group" class="anchor"></a><code><span class="keyword">val</span> pp_group : <a href="index.html#type-group">group</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_address"><a href="#val-pp_address" class="anchor"></a><code><span class="keyword">val</span> pp_address : <a href="index.html#type-address">address</a> Fmt.t</code></dt><dt class="spec value" id="val-pp_set"><a href="#val-pp_set" class="anchor"></a><code><span class="keyword">val</span> pp_set : <a href="index.html#type-set">set</a> Fmt.t</code></dt></dl></section><section><header><h3 id="equal-&amp;-compare."><a href="#equal-&amp;-compare." class="anchor"></a>Equal &amp; Compare.</h3></header><dl><dt class="spec type" id="type-equal"><a href="#type-equal" class="anchor"></a><code><span class="keyword">type</span> 'a equal</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec type" id="type-compare"><a href="#type-compare" class="anchor"></a><code><span class="keyword">type</span> 'a compare</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt></dl><dl><dt class="spec value" id="val-case_sensitive"><a href="#val-case_sensitive" class="anchor"></a><code><span class="keyword">val</span> case_sensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p>Alias of <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>.</p></dd></dl><dl><dt class="spec value" id="val-case_insensitive"><a href="#val-case_insensitive" class="anchor"></a><code><span class="keyword">val</span> case_insensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>case_insensitive a b</code> maps values with <code>lowercase_ascii</code> and compare them with <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>. We <b>do not</b> map UTF8 value.</p></dd></dl><dl><dt class="spec value" id="val-equal_word"><a href="#val-equal_word" class="anchor"></a><code><span class="keyword">val</span> equal_word : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal ~compare a b</code> tests if <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> are semantically equal. <code>compare</code> specifies implementation to compare two <code>string</code> (i.e. to be case-sensitive or not).</p></dd></dl><dl><dt class="spec value" id="val-compare_word"><a href="#val-compare_word" class="anchor"></a><code><span class="keyword">val</span> compare_word : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_word ?case_sensitive a b</code> compares <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> semantically. From standards, <a href="index.html#type-word"><code>word</code></a> SHOULD be case-sensitive, the client can notice this behaviour by <code>?case_sensitive</code> (default is <code>true</code>).</p></dd></dl><dl><dt class="spec value" id="val-equal_raw"><a href="#val-equal_raw" class="anchor"></a><code><span class="keyword">val</span> equal_raw : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_raw a b</code> tests if <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> are semantically equal. <i>Semantically equal</i> means we compare raw's content, by this way, a <code>Base64</code> raw could be equal to a <code>Quoted_printable</code> raw if and only if <code>string</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-compare_raw"><a href="#val-compare_raw" class="anchor"></a><code><span class="keyword">val</span> compare_raw : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_raw a b</code> compares <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> semantically.</p></dd></dl><dl><dt class="spec value" id="val-equal_phrase"><a href="#val-equal_phrase" class="anchor"></a><code><span class="keyword">val</span> equal_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_phrase a b</code> tests if <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> are semantically equal. In this case, the comparison is case-insensitive between elements in <a href="index.html#type-phrase"><code>phrase</code></a>. The order of elements is important.</p></dd></dl><dl><dt class="spec value" id="val-compare_phrase"><a href="#val-compare_phrase" class="anchor"></a><code><span class="keyword">val</span> compare_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_phrase a b</code> compares <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> semantically.</p></dd></dl><dl><dt class="spec value" id="val-equal_addr"><a href="#val-equal_addr" class="anchor"></a><code><span class="keyword">val</span> equal_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_addr a b</code> tests if <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code> are semantically equal. An <code>IPv4</code> should be equal with an <code>IPv6</code> address. Then, for extended kind, we strictly compare (<span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span>) kind and value.</p></dd></dl><dl><dt class="spec value" id="val-compare_addr"><a href="#val-compare_addr" class="anchor"></a><code><span class="keyword">val</span> compare_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_addr a b</code> compares <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code>, we prioritize <code>IPv6</code>, <code>IPv4</code> and finally <code>Ext</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_domain"><a href="#val-equal_domain" class="anchor"></a><code><span class="keyword">val</span> equal_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_addr a b</code> tests if <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-domain"><code>domain</code></a> <code>b</code> are semantically equal. We <b>do not</b> resolve domain, a <code>`Domain</code> could be semantically equal to another <code>`Domain</code> if they point to the same <code>IPv4</code>/<code>IPv6</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_domain"><a href="#val-compare_domain" class="anchor"></a><code><span class="keyword">val</span> compare_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>comapre_domain a b</code> compares <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-domain"><code>domain</code></a> <code>b</code>, we prioritize <code>`Domain</code>, <code>`Literal</code> and finally <code>`Addr</code>. The comparison between two <code>`Literal</code> and between part of <code>`Domain</code> are case-insensitive.</p></dd></dl><dl><dt class="spec value" id="val-equal_domains"><a href="#val-equal_domains" class="anchor"></a><code><span class="keyword">val</span> equal_domains : (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list) <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_domains a b</code> apply <a href="index.html#val-equal_domain"><code>equal_domain</code></a> to ordered domains (see <a href="index.html#val-compare_domain"><code>compare_domain</code></a>) between <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_domains"><a href="#val-compare_domains" class="anchor"></a><code><span class="keyword">val</span> compare_domains : (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list) <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_domains a b</code> compares ordered list of <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and ordered list of <a href="index.html#type-domain"><code>domain</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_local"><a href="#val-equal_local" class="anchor"></a><code><span class="keyword">val</span> equal_local : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_local ?case_sensitive a b</code> tests if <a href="index.html#type-local"><code>local</code></a> <code>a</code> and <a href="index.html#type-local"><code>local</code></a> <code>b</code> are semantically equal. Standards notices local-part SHOULD be case-sensitive, the client can choose this behaviour with <code>case_sensitive</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_local"><a href="#val-compare_local" class="anchor"></a><code><span class="keyword">val</span> compare_local : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_local ?case_sensitive a b</code> compares <a href="index.html#type-local"><code>local</code></a> <code>a</code> and <a href="index.html#type-local"><code>local</code></a> <code>b</code> semantically. The user can decide if the comparison is case-sensitive or not (with <code>case_sensitive</code>).</p></dd></dl><dl><dt class="spec value" id="val-equal_mailbox"><a href="#val-equal_mailbox" class="anchor"></a><code><span class="keyword">val</span> equal_mailbox : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_mailbox ?case_sensitive a b</code> tests if <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>b</code> are semantically equal. The user can define if the local-part need to be case-sensitive or not (by <code>case_sensitive</code>). If <code>a</code> xor <code>b</code> has a name, we consider <code>a = b</code> if we have the same local-part and same domain(s). Otherwise, we compare identifier/<a href="index.html#type-phrase"><code>phrase</code></a> between them.</p></dd></dl><dl><dt class="spec value" id="val-compare_mailbox"><a href="#val-compare_mailbox" class="anchor"></a><code><span class="keyword">val</span> compare_mailbox : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare ?case_sensitive a b</code> compares <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <code>mailbxo</code> <code>b</code> semantically. We prioritize local-part, domain-part and finally optionnal name.</p></dd></dl><dl><dt class="spec value" id="val-compare_group"><a href="#val-compare_group" class="anchor"></a><code><span class="keyword">val</span> compare_group : <a href="index.html#type-group">group</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>comapre_group a b</code> compares <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code>. We compare the group name first and compare ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></dd></dl><dl><dt class="spec value" id="val-equal_group"><a href="#val-equal_group" class="anchor"></a><code><span class="keyword">val</span> equal_group : <a href="index.html#type-group">group</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_group a b</code> tests if <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code> are semantically equal. We compare first group name and ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></dd></dl><dl><dt class="spec value" id="val-compare_address"><a href="#val-compare_address" class="anchor"></a><code><span class="keyword">val</span> compare_address : <a href="index.html#type-address">address</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_address a b</code> compares semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code>* and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_address"><a href="#val-equal_address" class="anchor"></a><code><span class="keyword">val</span> equal_address : <a href="index.html#type-address">address</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_address a b</code> tests semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code> and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_set"><a href="#val-equal_set" class="anchor"></a><code><span class="keyword">val</span> equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal a b</code> tests semantically <a href="index.html#type-set"><code>set</code></a> <code>a</code> and <a href="index.html#type-set"><code>set</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_set"><a href="#val-compare_set" class="anchor"></a><code><span class="keyword">val</span> compare_set : <a href="index.html#type-set">set</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare a b</code> compares <a href="index.html#type-set"><code>set</code></a> <code>a</code> and <a href="index.html#type-set"><code>set</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-strictly_equal_set"><a href="#val-strictly_equal_set" class="anchor"></a><code><span class="keyword">val</span> strictly_equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p>A structurally equal function on <a href="index.html#type-set"><code>set</code></a>.</p></dd></dl></section><section><header><h3 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h3><p>If you don't want a headache, you should move on.</p></header><div class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Invalid" class="anchored"><td class="def constructor"><a href="#type-error.Invalid" class="anchor"></a><code>| </code><code>`Invalid <span class="keyword">of</span> string * string list</code></td></tr><tr id="type-error.Incomplete" class="anchored"><td class="def constructor"><a href="#type-error.Incomplete" class="anchor"></a><code>| </code><code>`Incomplete</code></td></tr></table><code> ]</code></dt><dd><p>The error type.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <a href="index.html#type-error">error</a> Fmt.t</code></dt><dd><p><code>pp_error ppf err</code> is pretty-printer of <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-address_of_string_with_crlf"><a href="#val-address_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> address_of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>address_of_string_with_crlf s</code> parses <code>s</code> which have the form: <code>local@domain</code>. Named email or multiple-domain email are not handle by this parser. <code>s</code> must terminate with <code>CRLF</code>. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-address_of_string"><a href="#val-address_of_string" class="anchor"></a><code><span class="keyword">val</span> address_of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>address_of_string s</code> parses <code>s</code> which have the form: <code>local@domain</code>. Named email or multiple-domain email are not handle by this parser. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-address_of_string_raw"><a href="#val-address_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> address_of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a> * int, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>address_of_string_raw s off len</code> parses a sub-part of <code>s</code> starting at <code>off</code> and it computes at most <code>len</code> bytes. It returns the email and how many bytes it consumes. Named email or multiple-domain are not handle by this parser. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_of_string_with_crlf"><a href="#val-set_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> set_of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dt class="spec value" id="val-set_of_string"><a href="#val-set_of_string" class="anchor"></a><code><span class="keyword">val</span> set_of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dt class="spec value" id="val-set_of_string_raw"><a href="#val-set_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> set_of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a> * int, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dt class="spec value" id="val-of_string_with_crlf"><a href="#val-of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>of_string_with_crlf s</code> parses <code>s</code> which can have multiple form:</p><ul><li>Named email <code>Bobby &lt;bobby@mail.net&gt;</code></li><li>Multiple-domain email <code>&lt;@laposte.net:bobby@mail.net</code></li><li>Usual form <code>bobby@mail.net</code></li><li>Surrounded form <code>&lt;bobby@mail.net&gt;</code></li></ul><p>About named email, the parser handles <i>encoded-word</i> (according RFC 2047) to be able to use a special <i>charset</i> (like UTF-8) to show the name. Parser decodes <i>encoded-word</i> as is and do not any translation from <i>charset</i> specified to any encoding.</p><p><code>s</code> must terminates with <code>CRLF</code>. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>of_string s</code> is <a href="index.html#val-of_string_with_crlf"><code>of_string_with_crlf</code></a> but did not need <code>CRLF</code> at the end.</p></dd></dl><dl><dt class="spec value" id="val-of_string_raw"><a href="#val-of_string_raw" class="anchor"></a><code><span class="keyword">val</span> of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a> * int, <a href="index.html#type-error">error</a>) Stdlib.result</code></dt><dd><p><code>of_string_raw s off len</code> is <a href="index.html#val-of_string_with_crlf"><code>of_string_with_crlf</code></a> but did not need <code>CRLF</code> at the end. It parses only a sub-part of <code>s</code> starting at <code>off</code> and computes at most <code>len</code> bytes. It returns how many bytes it consumed.</p></dd></dl></section></div></body></html>